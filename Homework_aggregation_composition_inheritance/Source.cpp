#include <memory>
class Engine {
public:
    void start() {
        // код для запуска двигателя
    }
};

class Car {
public:
    Car(Engine engine) : m_engine(engine) {}

    void drive() {
        m_engine.start();
        // код для езды на машине
    }

private:
    Engine m_engine;
};

//Плюсы агрегации:

//Простота в использовании и понимании.
//Гибкость при создании объектов классов, так как можно передавать любой объект класса в качестве аргумента.
//Меньшая связность классов, что позволяет избежать сложных зависимостей между классами.

//Минусы агрегации :

//При агрегации классов объекты класса, которые были переданы в качестве аргумента, живут вне созданного класса.
//Это может быть нежелательно в том случае, когда мы хотим, чтобы объекты класса были зависимы от созданного класса.

//Класс, который содержит агрегированные объекты, не может контролировать их жизненный цикл, что может привести к утечкам памяти.


class Wheel {
public:
    void rotate() {
        // код для вращения колеса
    }
};

class Car {
public:
    Car() : m_wheel(new Wheel) {}

    void drive() {
        m_wheel->rotate();
        // код для езды на машине
    }

private:
    std::unique_ptr<Wheel> m_wheel;
};

//Плюсы композиции :
//
//Объекты класса, которые создаются внутри созданного класса, зависят от созданного класса.Это может быть желательно в том случае, когда мы хотим, чтобы объекты класса были автоматически удалялись, когда созданный класс удаляется.
//Класс, который содержит объекты другого класса, может контролировать их жизненный цикл.
//Минусы композиции :
//
//Большая связность между классами, что может привести к сложным зависимостям.
//Сложность в использовании и понимании, особенно если созданный класс содержит множество объектов другого класса.